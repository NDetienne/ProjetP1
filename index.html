<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Projet P1 - Partie Informatique by UCL-INGI</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Projet P1 - Partie Informatique</h1>
        <p></p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/UCL-INGI/Projet-P1" class="button fork"><strong>View On GitHub</strong></a>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a id="1-le-matériel" class="anchor" href="#1-le-mat%C3%A9riel" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1) Le matériel</h1>

<p>La « brique » NXT, fabriquée par Lego, est une version du système Lego Mindstorms dotée d’un microprocesseur ARM7 32 bits avec 256 ko de mémoire flash, dont 64 ko de mémoire vive (RAM).</p>

<p><center><img src="images/manuel/brique.png" alt="brique"></center></p>

<p>Le NXT est équipé de connexion sans fil Bluetooth (classe II V2.0) et d'un port USB 2.0. 
Ces connexions permettent au NXT de se connecter facilement aux PCs. 
Pour son alimentation, le NXT a une batterie lithium rechargeable et peut également fonctionner sur six piles AA. </p>

<p><img src="images/manuel/alim.png" alt="alim"></p>

<p>Pour sa partie robotique, le NXT possède : </p>

<ul>
<li>Quatre ports d’entrée (1 à 4) destinées à la connexion de capteurs (il y a quatre types de capteurs : capteur tactile, capteur sonore, capteur photosensible et capteur d’ultrasons), </li>
<li>Trois ports de sortie (A, B, C) où des moteurs et des lampes peuvent être branchés. </li>
</ul>

<p>On peut contrôler le NXT par quatre boutons : </p>

<ul>
<li>Un bouton orange : pour allumer, valider ou démarrer un programme. </li>
<li>Deux boutons flèches gris clairs : pour déplacer le curseur ou la sélection (monter ou descendre dans les menus). </li>
<li>Un bouton gris foncé : pour éteindre ou retourner en arrière. </li>
</ul>

<p>En outre, le NXT est doté d’un haut-parleur et peut produire des sons à une fréquence de 8 kHz. </p>

<h1>
<a id="2-le-logiciel" class="anchor" href="#2-le-logiciel" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2) Le logiciel</h1>

<p>Dans le cadre du projet, vous allez écrire un programme en Java afin de piloter votre robot. LeJOS NXJ est un environnement de programmation Java pour le Lego Mindstorms NXJ. Pour utiliser LeJOS NXJ, on installe une extension NXJ dans BlueJ. </p>

<ul>
<li>Cette extension ajoute un sous-menu qui permet de compiler et de télécharger les programmes Java dans le NXT. </li>
<li>Les programmes Java pour le NXT doivent être écrits et compilés sur un ordinateur avant d'être téléchargés dans la mémoire du NXT. </li>
<li>Après avoir préparé les programmes sur un ordinateur, on peut les télécharger dans NXT par la connexion (voir plus bas pour le téléchargement). </li>
<li>Une fois que les programmes sont chargés dans le mémoire de NXT, on peut choisir un programme (en utilisant les boutons de flèches) et le lancer avec le bouton orange. </li>
</ul>

<h1>
<a id="3-bluej" class="anchor" href="#3-bluej" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3) Bluej</h1>
<p><b>Les briques NXT sont prêtes à être utilisées, <u>il ne faut en aucun cas les flasher vous même</u> sous peine de mettre votre brique hors d'usage</b>.
<p><b>Utilisez votre dossier personnel sur les machines de salles afin de conserver votre travail d'une connexion à l'autre. Chaque année des étudiants perdent leur travail à cause du nom respect des consignes</b>.
<h2>
<a id="31-démarrer-bluej-en--candix-daoiao" class="anchor" href="#31-d%C3%A9marrer-bluej-en-candix-daoiao" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.1) Démarrer Bluej en BarbXX, Candix (DAO/IAO...)</h2>

<ul>
<li>Démarrez l'ordinateur sous Fedora (choisissez Fedora lors de la séquence de démarrage de l'ordinateur) et identifiez-vous.</li>
<li>Sélectionnez "Activités" - "Afficher les applications" dans la barre de gauche.</li>
<li>Sélectionnez <strong>BluejNXT</strong> (attention sélectionnez bien BluejNXT et non Bluej).</li>
<li>BluejNXT va démarrer Bluej avec l'extension NXT déjà configurée.</li>
<li>Une autre possibilité pour le démarrer est d'ouvrir un terminal puis de taper la commande <em>bluejnxt</em>
<li>En Barb, utilisez la rallonge USB sortant de l'arrière de l'écran car seul celui-ci est USB-2.</li>
<li>En Candix, utilisez les ports USB de l'écran car seuls ceux-ci sont USB-2.</li>
</li>
</ul>

<h2>
<a id="32-installation-sur-votre-portable" class="anchor" href="#32-installation-sur-votre-portable" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2) Installation sur votre portable</h2>
<p>Lors de ses passages dans vos locaux, le responsable informatique du projet répondra aux questions concernant la partie informatique du projet, la programmation des Légo etc, mais vu le nombre d'étudiants et la diversité des systèmes d'exploitation, aucun support à l'installation de Bluej et de l'extentions NXJ sur votre machine ne sera donné à ce moment là.

<p>
<p><u>Des permanences</u> spécialement <u>prévues</u> seront données <u>pour</u> vous aider en cas de problème lors de <u>l'installation de Bluej et de l'environnement LeJos BluejNXT sur votre portable</u>. La permanence n'est pas prévue pour installer à votre place, mais bien pour vous aider si vous rencontrer des difficultés.
Elles se donneront les <u><b>lundi, mardi et mercredi de S10</b></u> de 13h à 14h au Barb06. Si vous rencontrez des problèmes à l'installation, n'hésitez pas à y venir pour pouvoir commencer à programmer dans les plus brefs délais.
<p>

<h3>
<a id="321-via-virtualbox" class="anchor" href="#321-via-virtualbox" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2.1) Via VirtualBox</h3>
<p>Via VirtualBox, vous devriez rapidement savoir programmer votre robot depuis votre portable sans avoir à vous soucier de l'installer de Bluej et de l'extension NXJ.
<p>Il vous suffit d'installer VirtualBox puis de charger l'image de la machine virtuelle qui a été configurée pour vous avec Bluej et NXJ sous Linux (Fedora). L'UCL (SISE) met à votre disposition cette image VirtualBox ainsi qu'une vidéo qui a été faite pour vous montrer, pas à pas, les étapes à suivre pour charger cette machine virtuelle dans Virtualbox.
<p>Virtualbox est téléchargeable ici: <a href="https://rdav.sgsi.ucl.ac.be/dfs/groups/d/did-sst-commun/EPL/Virtualbox_Didac_Fedora/" target=_blank>https://rdav.sgsi.ucl.ac.be/dfs/groups/d/did-sst-commun/EPL/Virtualbox_Didac_Fedora/</a>
<p>L'image de la machine virtuelle <a href="https://rdav.sgsi.ucl.ac.be/dfs/groups/d/did-sst-commun/EPL/Virtualbox_Didac_Fedora/Fedora.vdi" target=_blank>Virtualbox contenant Bluej</a> et la <a href="https://rdav.sgsi.ucl.ac.be/dfs/groups/d/did-sst-commun/EPL/Virtualbox_Didac_Fedora/virtualbox_lejos.mov" target=_blank>vidéo d'installation</a> se trouvent ici: <a href="https://rdav.sgsi.ucl.ac.be/dfs/groups/d/did-sst-commun/EPL/Virtualbox_Didac_Fedora/" target="_blank">https://rdav.sgsi.ucl.ac.be/dfs/groups/d/did-sst-commun/EPL/Virtualbox_Didac_Fedora/</a>. Ce répertoire distant est également monté sur vos postes de travail en salles.<p>
<p>Le mot de passe du compte <i>student</i> sous l'image VirtualBox est <i>1234</i>. N'hésitez pas à le modifier dans Applications - Paramètres - Utilisateurs - Mot de passe.</p> 
<p>Si vous le désirez, vous pouvez créer un nouvel utilisateur, allez dans Applications - Paramètres - Utilisateurs, cliquez sur Déverouiller, entrez le mot de passe <i>1234</i> puis cliquez sur le "+" de la colonne de gauche. Remplissez les différents champs puis validez en cliquant sur "Ajouter".</p>
<a id="3211-Problemes-rencontrés" class="anchor" href="#3211-Problemes-rencontrés" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2.1.1) Problèmes rencontrés:</h4>
<p><i>This kernel requires an x86-64 CPU, but only detected an i686 CPU.</i>
<ul>
<li>Sélectionnez "Fedora(64bits)" dans la configuration de votre image VirtualBox (clic droit sur le nom de la machine, puis "configuration", sélectionnez "Général" et l'onglet "Basic" puis le menu déroulant du champ Version.</li>
<li>Si aucune version 64bits n'est proposée, désactivez Hyper-V si il est actif sur votre Windows</li>
<li>Si ça ne résoud pas le problème, vérifiez les paramètres de votre BIOS (au démarrage de votre portable), il faut activer "Virtualization Technology" et "VT-d". Ca devrait se trouver dans Advanced BIOS Features puis dans la partie CPU)</li>
</ul></p>
<p><i>No NXT found - is it switched on and plugged in (for USB)?</i>
<ul>
<li>Suivre la procédure décrite dans la vidéo d'aide à l'installation permettant de partager l'USB avec l'image VirtualBox. Ceci va rendre visible la brique NXT depuis votre machine Fedora.</li>
<li>Branchez de préférence la brique sur un port USB2, si disponible.</li>
<li>La brique doit être allumée pendant l'étape 1 ci-dessus ainsi que pendant le téléchargement du programme sur la brique.</li>
</ul></p>

<h3>
<a id="322-directement-sur-votre-portable" class="anchor" href="#322-directement-sur-votre-portable" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2.2) Directement sur votre portable</h3>
<p>Cette methode est plus fastidieuse, mais il est possible d'installer sur votre portable Bluej et les librairies nécessaires pour compiler votre programme et l'uploader sur la brique.
<h4>
<a id="3221-Sous-Linux" class="anchor" href="#3221-Sous-Linux" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2.2.1) Sous Linux</h4>
<ul>
<li> Il faut commencer par installer les paquets dont Lejos NXJ aura besoin. Il s'agit de Development files for libusb (libusb-devel) et Development Libraries for Bluetooth applications (bluez-libs-devel). Exemple sous RedHat : $ yum install libsusb-devel bluez-libs-devel</li>
<li> Installez le Java Development Kit (JDK v1.6 ou supérieure)</li>
<li> Téléchargez Lejos NXJ sur la page du site de Lejos :  http://lejos.sourceforge.net/nxj-downloads.php</li>
<li> Dé-archivez le fichier .tar.gz dans un répertoire (appelé plus loin NXJ_HOME). </li>
<li> Initialisez la variable d'environnement JAVA_HOME vers le répertoire d'installation du JDK</li>
<li> Initialisez la variable d'environnement NXJ_HOME vers le répertoire d'installation (4ème point de cette liste)</li>
<li> Ajoutez $JAVA_HOME/bin et $NXJ_HOME/bin à la variable d'environnement PATH. Par facilité ces trois derniers points peuvent se faire via le fichier ~/.bashrc comme ci-dessous :</li>
<p><img src="images/manuel/installLinux1.png" alt="installLinux1"></p>
<li> Ouvrez un terminal et construisez Lejos NXJ. Pour ce faire, allez dans le répertoire d'installation de Lejos NXJ (NXJ_HOME/build) et exécutez la commande ant. Si tous les paquets dont il dépend sont installés, Lejos NXJ est construit sans aucune erreur.</li>
<li> Passons à présent à l'installation de l'extension Lejos NXT pour Bluej</li>
  <ol>
  <li>Téléchargez le fichier LeJOSNXTExtension.jar se trouvant sur Moodle</li>
  <li>Sauvegardez ce .jar dans le répertoire d'extensions de Bluej <path_to_bluej>/Bluej/lib/extensions/ 
Si vous ne connaissez pas le path, lancer une recherche (commande : find / -name  bluej)</li>
<p><img src="images/manuel/installLinux2.png" alt="installLinux2"></p>
   
  <li>Démarrez Bluej</li>
  <li>Cliquez sur Tools – Preferences...</li>
  <li>Cliquez sur l'onglet Libraries puis sur le bouton Add</li>
<p><img src="images/manuel/installLinux3.png" alt="installLinux3"></p>
  <li>Recherchez le répertoire <NXJ_HOME>/lib et sélectionnez le fichier classes.jar </li>
  <li> Validez. Le statut de la librairie est Not loaded. C'est normal elle sera chargée au prochain redémarrage de Bluej.</li>
<p><img src="images/manuel/installLinux4.png" alt="installLinux4"></p>
  <li>Cliquez à présent sur l'onglet Extensions (Tools – Preferences...) et encodez la localisation de lejos_nxt (NXT_HOME) comme ci-dessous :</li>
<p><img src="images/manuel/installLinux5.png" alt="installLinux5"></p>
  <li>La configuration est finie, redémarrez Bluej.</li>
  <li>Vous pouvez à présent compiler des programmes et les charger dans la brique NXT.</li>
  </ol>
   <li>Il faut être root pour pouvoir accéder en lecture et écriture au NXT par USB. Si vous ne l'êtes pas exécutez la commande suivante :
$ sudo chmod -R 777 /dev/bus/usb</li>
</ul>

<h4>
<a id="3222-Sous-Windows" class="anchor" href="#3221-Sous-Windows" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2.2.1) Sous Windows
</h4>
<ul>
<li>1) Installez le JDK Java en 32-bit (x86) peu importe l’architecture de son système. Vous pouvez le télécharger ici : http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</li>
<li>Installez la dernière version de LeJOS (http://sourceforge.net/projects/lejos/files/lejos-NXJ/)</li>
<ol>
  <li>Acceptez le contrôle utilisateur (permission administrateur)</li>
  <li>Next > Sélectionnez le JDK installé (32-bit).</li>
     <p><img src="images/manuel/installWin1.png" alt="installWin1"></p>
  <li>Appuyez 4 fois sur Next >  Si message d’erreur apparaît disant qu’une ancienne version est déjà installée, cliquez sur ok. </li>
  <li>Install >   A la fin, décochez le reset flash utility</li>
</ol>
<li>Installez un driver USB. Ils sont disponibles sur Moodle (FSAB1401 – Documents et liens – NXT)</li>
<li>Installez l'extension de Bluej (voir partie Linux)</li>
<li>Modifiez les variables globales (permission administrateur) :</li>
<ol>
<li>Allez sur Panneau de configuration </li>
<li>Système et Sécurité   > Système   > Paramètres et système avancés > (onglet) Paramètres système avancés </li>
<li>Cliquez sur variable environnement </li>
<li>Dans variables système, sélectionnez « Path » et modifiez en ajoutant un point-virgule à fin de ce qui précède puis le chemin du JDK (exemple :   C:\Program Files (x86)\Java\jdk1.7.0_45\bin )</li>
<li>Tout confirmer </li>
<li>Redémarrez l’ordinateur </li>
</ol>
</ul>

<p>Vous trouverez un autre tutoriel pour l'installation ici: <a href="https://github.com/jneug/bluej-lejos">https://github.com/jneug/bluej-lejos</a>


<h2>
<a id="33-tester-linstallation-et-le-robot-sur-base-dun-exemple" class="anchor" href="#33-tester-linstallation-et-le-robot-sur-base-dun-exemple" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.3) Tester l'installation et le robot sur base d'un exemple</h2>

<p>Afin de tester, à la fois l'installation de l'extension et le matériel que vous avez reçu vous pouvez télécharger le programme de test (SimpleControler) présent sur <a href="https://github.com/UCL-INGI/Projet-P1" target=_blank>GitHub</a> ainsi que sur le Moodle du cours LFSAB1401 (Documents, 7-NXT).  </p>

<ul>
<li>Téléchargez et décompressez l'archive dans un nouveau répertoire (exemple : /home/VOTRE_LOGIN/Documents/Projet-P1/) </li>
<li>Ouvrez le projet SimpleController dans Bluej (Project – Open Project – SimpleController ).</li>
<li>Compilez-le : clic droit sur la classe principale, possédant la méthode main (SimpleController dans ce cas-ci) et sélectionnez  NXJ  - NXJ-Compile . Ceci aura généré un fichier dont l'extension est « .nxj ».</li>
</ul>

<p><center><img src="images/manuel/bluej1.png" alt="bluej1"></center></p>

<p><center><img src="images/manuel/bluej2.png" alt="bluej2"></center></p>

<p>En cas d'erreur, vérifiez la configuration de Bluej :
Tools – Preferences – Librairies : il doit y avoir le <strong>classes.jar</strong> et il doit être dans le status <strong>loaded</strong>. Si ce n'est pas le cas, il faut l'ajouter (path = /opt/leJOS_NXJ/lib/nxt/classes.jar) et redémarrer Bluej.
Dans Tools – Preferences – Extensions la variable <strong>NXJ_HOME</strong> doit être égale à <strong>/opt/leJOS_NXJ</strong></p>

<h2>
<a id="34-télécharger-le-programme-dans-le-robot" class="anchor" href="#34-t%C3%A9l%C3%A9charger-le-programme-dans-le-robot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4) Télécharger le programme dans le robot:</h2>

<ul>
<li>Connectez le boitier NXT à l'ordinateur par le câble USB</li>
<li>Allumez-le (branchez-le également sur le secteur au besoin)</li>
<li>Poussez le programme sur le robot : clic droit sur la classe principale et sélectionnez NXJ  - NXJ-UploadUSB. Attention, le boitier doit être allumé pendant le transfert !</li>
<li>Si aucun message d'erreur ne s'affiche le programme est chargé dans le robot.</li>
</ul>

<p><center><img src="images/manuel/upload1.png" alt="upload1"></center></p>

<ul>
<li>Débranchez le câble USB et naviguez dans le menu du robot « Files » jusqu'à retrouver le programme SimpleController. Vous pouvez à présent l'exécuter « Execute Program » (branchez les moteurs et capteurs comme décrit dans le code afin de tester son fonctionnement).</li>
</ul>

<p><center><img src="images/manuel/upload2.png" alt="upload2"></center></p>

<h1>
<a id="4-comment-programmer-son-robot" class="anchor" href="#4-comment-programmer-son-robot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4) Comment programmer son robot</h1>

<p>La librairie concernant le fonctionnement des robots Lego est détaillée à <a href="http://lejos.sourceforge.net/nxt/nxj/api/index.html" target=_blank>cette page</a>.
Celle-ci contient de nombreuses classes spécifiques aux fonctionnalités des Lego Minstorms, groupées dans les packages dont le nom commence par « lejos » (n’oubliez pas les « import » correspondants dans votre programme !). Ce tutoriel n'a pas pour but de détailler toutes les possibilités de ces classes, mais donne un aperçu succinct et partiel des possibilités offertes par ces classes et méthodes. Ce qui suit est donc une entrée en matière suffisante pour la réalisation du projet P1.</p>

<h2>
<a id="41-les-senseurs-" class="anchor" href="#41-les-senseurs-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.1) Les senseurs</h2>

<p>La classe <strong>lejos.nxt.SensorPort</strong> représente un port d’entrée du NXT. Il y a quatre instances prédéfinies de la classe <strong>SensorPort</strong>, correspondant aux quatre ports d'entrée : <strong>SensorPort.S1</strong>, <strong>SensorPort.S2</strong>, <strong>SensorPort.S3</strong> et <strong>SensorPort.S4</strong>. 
Il existe également une classe correspondant à chaque type de senseur : </p>

<ul>
<li>Capteur tactile : classe <strong>lejos.nxt.TouchSensor</strong>
<p><center><img src="images/manuel/touchsensor.png" alt="touch"></center></p>

</li>
<li>Capteur sonore : classe <strong>lejos.nxt.SoundSensor</strong>
<p><center><img src="images/manuel/soundsensor.png" alt="sound"></center></p>
</li>
<li>Capteur photosensible : classe <strong>lejos.nxt.LightSensor</strong>
<p><center><img src="images/manuel/lightsensor.png" alt="light"></center></p>
</li>
<li>Capteur de distance à ultrasons : classe <strong>lejos.nxt.UltrasonicSensor</strong>
<p><center><img src="images/manuel/ultrasonicsensor.png" alt="ultra"></center></p>
</li>
</ul>

<p>Le constructeur de chacune de ces classes prend comme paramètre le <strong>SensorPort</strong> auquel le senseur est connecté. Chaque classe fournit une ou plusieurs méthodes permettant de lire la mesure du senseur correspondant. </p>

<p>Exemple :</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.*</span>; </br>

<span class="pl-smi">TouchSensor</span> touch <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TouchSensor</span>(<span class="pl-smi">SensorPort</span><span class="pl-c1"><span class="pl-k">.</span>S1</span>);           <span class="pl-c">// capteur tactile connecté au port S2. </span>
<span class="pl-k">if</span> (touch<span class="pl-k">.</span>isDown()) {                                        <span class="pl-c">// si le capteur tactile est touché,</span>
          <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> <span class="pl-k">+</span> sonic<span class="pl-k">.</span>getDistance());      <span class="pl-c">// affiche la distance vue par le capteur à ultrasons </span>
} </pre></div>

<h2>
<a id="42-les-moteurs-" class="anchor" href="#42-les-moteurs-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.2) Les moteurs</h2>

<p>La classe <strong>lejos.nxt.Motor</strong> permet d'accéder aux moteurs NXT. Elle fournit trois instances prédéfinies (de type <strong>NXTRegulatedMotor</strong>), correspondant aux trois ports de sortie du NXT : <strong>Motor.A</strong>, <strong>Motor.B</strong> et <strong>Motor.C</strong>.</p>
<p><center><img src="images/manuel/motor.png" alt="ultra"></center></p>


<p>La classe <strong>NXTRegulatedMotor</strong> représente un moteur. La méthode <strong>setSpeed</strong> permet d’ajuster la vitesse du moteur. Les moteurs NXT sont équipés d’un capteur de rotation intégré (tachymètre) qui permet d’offrir une large palette de méthodes différentes. Les méthodes <strong>getTachoCount()</strong> et <strong>resetTachoCount()</strong> permettent de lire et de remettre à zéro le compteur de rotation. Les autres méthodes, telles que <strong>rotate()</strong>, utilisent également ce compteur pour contrôler précisément le nombre de rotations du moteur. 
Les mouvements du moteur s'effectuent à leur vitesse propre, distincte de (et beaucoup plus lente que) la vitesse d'exécution du programme Java. 
Deux types de méthodes permettant de commander le mouvement du moteur existent, il s'agit des <strong>méthodes bloquantes</strong> et des <strong>méthodes non-bloquantes</strong> : </p>

<p>• Pour une <strong>méthode bloquante</strong>, l'amplitude du mouvement (nombre de degrés, de tours, distance, ...) est pré-déterminée et la méthode attend jusqu'à la fin du mouvement (exemple : <strong>Motor.A.rotate(90)</strong>) avant de passer à l'instruction suivante. Durant ce temps, l'exécution du programme est suspendue; il ne peut pas, par exemple, détecter un obstacle et arrêter prématurément le mouvement. </p>

<p>Les <strong>méthodes bloquantes</strong> <strong>rotate()</strong> et <strong>rotateTo(...)</strong> font tourner le moteur d'un angle donné ou jusqu'à un angle donné. Lorsque la rotation demandée est terminée, le programme passe à l'instruction suivante. </p>
<p>Attention, dans la majorité des cas vous utiliserez <strong>rotate()</strong> et non <strong>rotateTo()</strong> car <strong>rotate()</strong> est utilisé pour une <u>rotation relative</u>. A partir de la position actuelle <strong>rotate(5)</strong> fera bouger l'orientation du robot de 5° sur la droite dans tous les cas alors que <strong>rotateTo(5)</strong> est utilisé pour une <u>rotation absolue</u> et fera par exemple faire une rotation de 355° sur la gauche (pour s'arrêter à l'orientation 5°) si le tachéomètre indique que le robot a une orientation au début de l'instruction de 360°.

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.*</span>;</br>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>setSpeed(<span class="pl-c1">720</span>);   <span class="pl-c">// 2 rotations complètes par seconde.</span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>resetTachoCount(); <span class="pl-c">// Remettre le compteur à zéro</span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>rotate(<span class="pl-c1">90</span>);      <span class="pl-c">// Faire tourner le moteur d'1/4 tour.</span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>rotateTo(<span class="pl-c1">720</span>);   <span class="pl-c">// Faire tourner le moteur jusqu'à ce que le compteur atteigne 2x360°.
                         // Attention 90° déjà effectué au compteur, donc il ne tournera plus que de 630° sur la gauche. </span>
<span class="pl-k">int</span> angle <span class="pl-k">=</span> <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>getTachoCount();  <span class="pl-c">//Lire le compteur.</span></pre></div>

<p>• Une méthode est <strong>non-bloquante</strong> lorsque la méthode démarre le mouvement et se termine immédiatement, alors que le mouvement se poursuit (exemple <strong>Motor.A.forward()</strong>). Le programme doit donc lui-même arrêter les moteurs en temps opportun, soit après un certain délai (<strong>Thread.sleep(...)</strong>), soit lorsqu'une condition est vérifiée. En attendant, le programme doit absolument libérer le processeur (<strong>Thread.yield()</strong>), pour permettre aux autres tâches de s'exécuter. 
Les méthodes non-bloquantes <strong>forward()</strong> et <strong>backward()</strong> démarrent le moteur en marche avant ou arrière et passent tout de suite à l'instruction suivante. Les méthodes <strong>flt()</strong> et <strong>stop()</strong> permettent d'arrêter le moteur. La méthode <strong>stop()</strong> empêche le moteur de tourner tandis que <strong>flt()</strong> le laisse « flotter » librement.</p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>resetTachoCount();       <span class="pl-c">// Remettre le compteur à zéro </span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>forward();              <span class="pl-c"> // Démarrer le moteur en avant. </span>
<span class="pl-smi">Thread</span><span class="pl-k">.</span>sleep(<span class="pl-c1">1000</span>);             <span class="pl-c"> // Attendre 1 seconde tout en roulant </span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>stop();                 <span class="pl-c"> // Arrêter de moteur. </span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>backward();             <span class="pl-c"> // Démarrer le moteur en arrière. </span>
<span class="pl-k">while</span> (<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>getTachoCount() <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {  <span class="pl-c">// Tant que le compteur ne revient pas à 0... </span>
         <span class="pl-smi">Thread</span><span class="pl-k">.</span>yield();        <span class="pl-c"> // Libérer le processeur. </span>
} 
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>stop();                 <span class="pl-c"> // Arrêter de moteur. </span></pre></div>

<p>Plusieurs méthodes bloquantes sont proposées avec une variante non-bloquante, comme par exemple <strong>rotate(...)</strong> et <strong>rotateTo(...)</strong> en ajoutant <strong>true</strong> comme argument  (voir ci-dessous). La méthode <strong>isMoving()</strong> permet de tester si le moteur tourne toujours.</p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>rotate(<span class="pl-c1">360</span><span class="pl-k">*</span><span class="pl-c1">10</span>, <span class="pl-c1">true</span>); <span class="pl-c">// Démarrer le moteur pour 10 tours. </span>
<span class="pl-k">while</span> (<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>isMoving()) {  <span class="pl-c">// Tant que le moteur tourne... </span>
      <span class="pl-k">int</span> angle <span class="pl-k">=</span> <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>getTachoCount();      <span class="pl-c">// Lire le compteur... </span>
      <span class="pl-c1">LCD</span><span class="pl-k">.</span>drawInt(angle,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>);                  <span class="pl-c"> // et l'afficher. </span>
} </pre></div>

<h2>
<a id="43-pilotage-dun-robot-roulant-" class="anchor" href="#43-pilotage-dun-robot-roulant-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.3) Pilotage d'un robot roulant</h2>

<p>La classe <strong>lejos.robotics.navigation.DifferentialPilot</strong> permet de piloter un robot roulant avec deux roues sur un même axe, contrôlées par deux moteurs séparés (châssis de type « chaise roulante ») et une roue libre dite « folle »: 
Les constructeurs permettent de déclarer la géométrie du châssis. Les paramètres de distance peuvent être dans une unité quelconque, pourvu que cette unité soit la même dans tout le programme.</p>

<p>Exemple pour un robot dont les roues gauche et droite sont sur les moteurs A et C : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.*</span>; 
<span class="pl-k">import</span> <span class="pl-smi">lejos.robotics.navigation.*</span>; 

<span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">DIAM_ROUE</span> <span class="pl-k">=</span> <span class="pl-c1">2.1f</span>;   <span class="pl-c">// Diamètre des roues motrices en cm</span>
<span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">DIST_ROUE</span> <span class="pl-k">=</span> <span class="pl-c1">4.4f</span>;   <span class="pl-c">// Distance entre les roues motrices en cm</span>
<span class="pl-smi">DifferentialPilot</span> pilot <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">DifferentialPilot</span>(<span class="pl-c1">DIAM_ROUE</span>, <span class="pl-c1">DIST_ROUE</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">C</span>); 
pilot<span class="pl-k">.</span>setTravelSpeed(<span class="pl-c1">10</span>);        <span class="pl-c">// Vitesse du robot = 10 cm/s. </span>
pilot<span class="pl-k">.</span>setRotateSpeed(<span class="pl-c1">45</span>);        <span class="pl-c">// Vitesse de pivotage = 45 degrés/s. </span></pre></div>

<p>Les méthodes (bloquantes) <strong>travel(...)</strong>, <strong>travelArc(...)</strong> et <strong>rotate(...)</strong> permettent ensuite de faire se déplacer le robot en ligne droite, selon un arc de cercle ou de le faire pivoter sur lui même. </p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre>pilot<span class="pl-k">.</span>travel(<span class="pl-c1">12</span>);                <span class="pl-c">// Avancer de 12 cm.</span>
pilot<span class="pl-k">.</span>rotate(<span class="pl-k">-</span><span class="pl-c1">90</span>);               <span class="pl-c">// Pivoter de 90 degrés vers la gauche.</span>
pilot<span class="pl-k">.</span>travel(<span class="pl-k">-</span><span class="pl-c1">12</span>);               <span class="pl-c">// Reculer de 12 cm.</span>
pilot<span class="pl-k">.</span>travelArc(<span class="pl-c1">10</span>, <span class="pl-c1">12</span>);         <span class="pl-c">// Faire un virage à gauche de 12 cm de long selon un rayon de 10 cm.</span>
pilot<span class="pl-k">.</span>arc(<span class="pl-k">-</span><span class="pl-c1">10</span>, <span class="pl-c1">90</span>);              <span class="pl-c">// Faire un virage à droite de 90 degrés selon un rayon de 10 cm.</span></pre></div>

<p>Les méthodes (non-bloquantes) <strong>forward()</strong>, <strong>backward()</strong>, <strong>arcForward()</strong>, <strong>arcBackward()</strong> et <strong>stop()</strong> permettent de démarrer un moteur pour une durée indéterminée et de l'arrêter.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-java"><pre>pilot<span class="pl-k">.</span>forward();        <span class="pl-c">// Avancer en ligne droite indéfiniment. </span>
<span class="pl-k">while</span>(<span class="pl-k">!</span><span class="pl-smi">Button</span><span class="pl-c1"><span class="pl-k">.</span>ENTER</span><span class="pl-k">.</span>isDown()) { <span class="pl-c">// Tant que le bouton orange n'est pas pressé...</span>
       <span class="pl-smi">Thread</span><span class="pl-k">.</span>yield();           <span class="pl-c">// Libérer le processeur. </span>
} 
pilot<span class="pl-k">.</span>stop();           <span class="pl-c">// Arrêter le robot. </span></pre></div>

<h2>
<a id="44-contrôle-par-tâches-" class="anchor" href="#44-contr%C3%B4le-par-t%C3%A2ches-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.4) Contrôle par tâches</h2>

<p>Un programme qui a pour but de contrôler un robot doit être réactif : il doit pouvoir adapter son comportement en fonction de l'évolution du monde physique dans lequel il évolue (repères extérieurs, obstacles, vitesse des moteurs, etc.). Réaliser un tel programme sous forme d'une cascade de conditions et de boucles peut paraître simple et intuitif mais conduit rapidement à du « code spaghetti » : un enchevêtrement inextricable de cas particuliers, difficile à lire, à maintenir et à mettre au point. </p>

<p>Il est possible d'utiliser un mécanisme de listeners, mais ceci conduit à des difficultés techniques et est découragé par les concepteurs de Lejos eux-mêmes. </p>

<p>Au lieu de cela, le package lejos.robotics.subsumption fournit une architecture de contrôle par tâche qui permet de réaliser un programme réactif, de manière modulaire. Le principe est de décomposer le programme en plusieurs tâches qui sont exécutées au besoin (<em>programmation événementielle</em>), en respectant un ordre de priorité, plutôt que de manière prédéterminée par le programme (<em>programmation séquentielle</em>). Ceci permet de caractériser clairement chaque aspect du comportement, et d'ajouter facilement des tâches supplémentaires.</p>

<p>Par exemple, un contrôleur de robot pourrait avoir les tâches suivantes : </p>

<ol>
<li><p>avancer en ligne droite </p></li>
<li><p>si un obstacle est détecté, virer d'un quart de tour vers la gauche </p></li>
<li><p>si un bouton est pressé sur la brique Lego, s'arrêter et mettre fin au programme. </p></li>
</ol>

<p>Ces tâches sont en ordre croissant de priorité : la tâche 1 s'exécutant tant que les autres tâches (plus prioritaires) ne sont pas activées.</p>

<h3>
<a id="441-définir-une-tâche" class="anchor" href="#441-d%C3%A9finir-une-t%C3%A2che" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.4.1) Définir une tâche</h3>

<p>Chaque tâche est définie par trois éléments, spécifiés par trois méthodes de l'interface Behavior : </p>

<h4>
<a id="4411-la-méthode-takecontrol" class="anchor" href="#4411-la-m%C3%A9thode-takecontrol" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.4.1.1) La méthode <strong>takeControl()</strong>
</h4>

<p>Elle fournit la condition d'activation qui détermine quand cette tâche doit être initiée. On peut vouloir qu'une action soit activée si un obstacle se trouve à moins de 25cm (voir exemple ci-dessous), ou si le capteur tactile est pressé. On peut également vérifier des conditions multiples. Exemple : La tâche est activée si, à la fois le capteur photosensible détecte une ligne noire ET si la valeur booléenne d'une variable est à true. Pour que la tâche soit activable, il faut que la valeur retournée par la méthode <strong>takecontrol()</strong> soit <strong>true</strong>. </p>

<h4>
<a id="4412-la-méthode-action" class="anchor" href="#4412-la-m%C3%A9thode-action" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.4.1.2) La méthode <strong>action()</strong>
</h4>

<p>Elle définit l'action que cette tâche doit accomplire (voir exemple ci-dessous). Cette méthode est appelée dès que la tâche devient active. </p>

<h4>
<a id="4413-la-méthode-suppress" class="anchor" href="#4413-la-m%C3%A9thode-suppress" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.4.1.3) La méthode <strong>suppress()</strong>
</h4>

<p>Cette méthode permet la suppression (l'arrêt) de l'action en cours d'exécution. Elle permet aussi de mettre à jour des données avant la fin de la tâche. Elle est appelée par l'<strong>Arbitrator</strong> sur la tâche en cours si la méthode <strong>takeControl()</strong> d'une tâche plus prioritaire retourne <strong>true</strong>. Si cette tâche arrêtée est réactivée plus tard durant l'exéction du programme, la méthode <strong>action()</strong> sera à nouveau exécutée depuis le début et non depuis l'endroit où elle avait été arrêtée précédemment.  </p>

<p>Pour définir une tâche, il faut réaliser une implémentation de cette interface définissant ces trois méthodes. Il s'agit d'une forme de programmation événementielle : on fournit au système de contrôle du robot différentes tâches à exécuter lorsque différents événements surviennent. Par exemple, la tâche suivante effectue une manoeuvre lorsqu'un obstacle est détecté par le senseur à ultrasons (sonar) : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.robotics.navigation.DifferentialPilot</span>; 
<span class="pl-k">import</span> <span class="pl-smi">lejos.robotics.subsumption.Behavior</span>; 
<span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.UltrasonicSensor</span>; 

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EviterBehavior</span> <span class="pl-k">implements</span> <span class="pl-e">Behavior</span> { 
    <span class="pl-k">private</span> <span class="pl-k">boolean</span> suppressed <span class="pl-k">=</span> <span class="pl-c1">false</span>; 
    <span class="pl-k">private</span> <span class="pl-smi">DifferentialPilot</span> pilote; 
    <span class="pl-k">private</span> <span class="pl-smi">UltrasonicSensor</span> sonar; 

    <span class="pl-k">public</span> <span class="pl-en">EviterBehavior</span>(<span class="pl-smi">DifferentialPilot</span> <span class="pl-v">pilote</span>, <span class="pl-smi">UltrasonicSensor</span> <span class="pl-v">sonar</span>) { 
        <span class="pl-v">this</span><span class="pl-k">.</span>pilote <span class="pl-k">=</span> pilote; 
        <span class="pl-v">this</span><span class="pl-k">.</span>sonar <span class="pl-k">=</span> sonar; 
    } 
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">action</span>() { 
        suppressed <span class="pl-k">=</span> <span class="pl-c1">false</span>;                     <span class="pl-c">// Remise à zéro  </span>
        pilote<span class="pl-k">.</span>arc(<span class="pl-c1">20.0</span>, <span class="pl-k">-</span><span class="pl-c1">90.0</span>, <span class="pl-c1">true</span>);          <span class="pl-c">// Entame un virage arrière sans attendre la fin. </span>
        <span class="pl-k">while</span> (<span class="pl-k">!</span>suppressed <span class="pl-k">&amp;&amp;</span> pilote<span class="pl-k">.</span>isMoving()) {  <span class="pl-c">// Tant que {suppress} n'a pas été  appelé et que le virage n'est pas terminé... </span>
            <span class="pl-smi">Thread</span><span class="pl-k">.</span>yield();     <span class="pl-c">// Libérer le processeur </span>
        } 
        pilote<span class="pl-k">.</span>stop();      <span class="pl-c">    // Arrêter le robot </span>
    } 
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">suppress</span>() { 
        suppressed <span class="pl-k">=</span> <span class="pl-c1">true</span>; 
    } 
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">takeControl</span>() {  
        <span class="pl-c">// Activer si un obstacle à moins de 25 cm </span>
        <span class="pl-k">return</span> sonar<span class="pl-k">.</span>getDistance() <span class="pl-k">&lt;</span> <span class="pl-c1">25</span>; 
    } 
} </pre></div>

<p>Attention au mécanisme de suppression de tâche ! La méthode <strong>suppress()</strong> est exécutée alors que la méthode <strong>action()</strong> est elle-même toujours en cours d'exécution. Elle n'arrête pas simplement la tâche en cours; au lieu de cela, elle doit signaler à la méthode <strong>action()</strong> que celle-ci doit d'elle-même interrompre son activité. Pour assurer cette synchronisation, on utilise la variable d'instance <strong>suppressed</strong> comme suit : </p>

<p>• La méthode <strong>action()</strong> met la variable <strong>suppressed</strong> à false initialement, </p>

<p>• La méthode <strong>suppress()</strong>, lorsqu'elle est appelée, met la variable <strong>suppressed</strong> à true, </p>

<p>• La méthode <strong>action()</strong> surveille continuellement la variable <strong>suppressed</strong> via la condition de boucle. </p>

<p>Si la variable <strong>suppressed</strong> de la tâche en cours devient <strong>true</strong> (indiquant que la méthode <b>suppress()</b> a été exécutée), le mouvement en cours est interrompu (pilote.stop()) et la méthode retourne immédiatement. La méthode doit donc utiliser des méthodes non-bloquantes sous peine d'ajouter un délai avant la prise en compte du passage de la variable à <strong>true</strong>. </p>

<p>La suppression (interruption) de la tâche n'est nécessaire que si action perdure dans le temps ; si elle se termine immédiatement il n'est pas nécessaire de mettre en place un mécanisme pour la supprimer. Par exemple, l'action de la tâche suivante quittant immédiatement le programme il est inutile de prévoir sa suppression. </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">StopBehavior</span> <span class="pl-k">implements</span> <span class="pl-e">Behavior</span> { 
    <span class="pl-k">private</span> <span class="pl-smi">DifferentialPilot</span> pilote; 

    <span class="pl-k">public</span> <span class="pl-en">StopBehavior</span>(<span class="pl-smi">DifferentialPilot</span> <span class="pl-v">pilote</span>) { 
        <span class="pl-v">this</span><span class="pl-k">.</span>pilote <span class="pl-k">=</span> pilote; 
    } 

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">action</span>() { 
        pilote<span class="pl-k">.</span>stop();      <span class="pl-c">// Arrêter le robot.</span>
        <span class="pl-smi">System</span><span class="pl-k">.</span>exit(<span class="pl-c1">0</span>);         <span class="pl-c">// Quitter le programme. </span>
    } 

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">suppress</span>() {    <span class="pl-c">// Rien à supprimer.</span>
    } 

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">takeControl</span>() {  
        <span class="pl-c">// Activer si le bouton ESCAPE est pressé. </span>
        <span class="pl-k">return</span> <span class="pl-smi">Button</span><span class="pl-c1"><span class="pl-k">.</span>ESCAPE</span><span class="pl-k">.</span>isDown(); 
    } 
} </pre></div>

<h3>
<a id="442-créer-un-contrôleur" class="anchor" href="#442-cr%C3%A9er-un-contr%C3%B4leur" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.4.2) Créer un contrôleur</h3>

<p>La classe <strong>Arbitrator</strong> permet de construire et d'activer un contrôleur par tâche. Son constructeur prend en paramètre un tableau contenant les tâches que le robot sera succeptible d'effectuer et que l'<strong>Arbitrator</strong> devra gérer. Les tâches doivent être ordonnées par <em><u>ordre croissant de priorité</u></em>. La méthode <strong>start()</strong> permet d'activer l'<strong>Arbitrator</strong>. </p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">DifferentialPilot</span> pilote <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">DifferentialPilot</span>(<span class="pl-c1">DIAM_ROUE</span>, <span class="pl-c1">DIST_ROUE</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">C</span>); 
<span class="pl-smi">UltrasonicSensor</span> sonar <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">UltrasonicSensor</span>(<span class="pl-smi">SensorPort</span><span class="pl-c1"><span class="pl-k">.</span>S1</span>);

<span class="pl-smi">Behavior</span> avancer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">AvancerBehavior</span>(pilote);         <span class="pl-c">// Tâche avancer (tout droit indéfiniment).</span>
<span class="pl-smi">Behavior</span> eviter <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">EviterBehavior</span>(pilote, sonar); <span class="pl-c">// Tâche eviter (manoeuvre arrière en cas d'obstacle).</span>
<span class="pl-smi">Behavior</span> stop <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StopBehavior</span>(pilote);            <span class="pl-c">// Tâche stop (arrêter tout si un bouton est appuyé). </span>
<span class="pl-k">Behavior</span>[] taches <span class="pl-k">=</span> { avancer, eviter, stop };       <span class="pl-c">// Tableau de tâches dans l'ordre croissant de priorité.</span>
<span class="pl-smi">Arbitrator</span> arbitre <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Arbitrator</span>(taches); 
arbitre<span class="pl-k">.</span>start(); </pre></div>

<p>Une tâche ne sera activée que si elle est activable (<b>takeControl()</b> retourne <b>true</b>) et qu'elle est plus prioritaire que la tâche en cours. Elle ne pourra être interrompue que par une tâche plus prioritaire qu'elle. L'activation et l'interruption d'une tâche ne peut avoir lieu qu'au moment où la tâche en cours exécute une méthode non bloquante. Simultanément, le contrôleur évalue en permanence les méthodes <strong>takeControl()</strong> de la liste des tâches et initie la tâche la plus prioritaire pour laquelle la méthode <strong>takeControl()</strong> retourne <strong>true</strong>, en appelant au besoin <strong>suppress()</strong> pour supprimer la tâche en cours (moins prioritaire). 
Attention : le bon fonctionnement de ce mécanisme dépend du fait que la méthode action() de chaque tâche se termine rapidement lorsque la méthode <strong>suppress()</strong> est appelée. </p>

<p>A tout moment, une seule tâche est activée ; une nouvelle tâche ne peut s'enclencher que lorsque la tâche en cours s'interrompt. Pour ce faire, le contrôleur appelle uniquement <strong>suppress()</strong> de la tâche en cours (moins prioritaire), puis appelle <strong>action()</strong> de la tâche à activer. Il ne peut pas forcer l'arrêt de l'exécution de action. Il est donc <u>très important</u> de bien appliquer le mécanisme de suppression des tâches décrit précédemment. </p>

<h1>
<a id="5-remarques-et-conseils" class="anchor" href="#5-remarques-et-conseils" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5) Remarques et conseils</h1>

<p>Un cours sur <a href="https://inginious.info.ucl.ac.be/course/LFSAB1501" target=_blank>INGInious</a> a été mis en place pour tester vos connaissances sur la programmation Légo, n'hsitez pas à répondre aux QCM. </p>

<p>Un exemple complet nommé <strong>SimpleController</strong>, dont sont tirés les extraits présentés ici, est disponible sur <a href="https://github.com/UCL-INGI/Projet-P1"  target=_blank>GitHub</a>. Utilisez-le comme point de départ. </p>

<p>Respectez bien les recommandations suivantes concernant la synchronisation afin d'éviter des problèmes de blocages et de conflits difficiles à diagnostiquer : </p>

<p>• Soyez attentifs à la différence entre méthodes bloquantes et non-bloquantes. </p>

<p>• Utilisez yield et/ou sleep à bon escient pour ne pas accaparer le processeur. </p>

<p>• Utilisez correctement la variable <strong>suppressed</strong> pour la suppression des tâches ainsi que les tests de valeurs de cette variable.</p>

<p>• Assurez-vous que vos tâches s'interrompent bien lorsque demandé. </p>

<p>Il est prudent d'avoir comme tâche de plus haute priorité une tâche d'arrêt d'urgence conditionnée sur un bouton du robot (par exemple la tâche StopBehavior de l'exemple fourni). </p>

<p>Les senseurs, moteurs et pièces mécaniques appartiennent au domaine de la physique : leur précision peut donc varier, une étape de calibrage peut être nécessaire... </p>

<h1>
<a id="6-documentation-" class="anchor" href="#6-documentation-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6) Documentation</h1>

<ol>
<li><p><a href="https://inginious.info.ucl.ac.be/course/LFSAB1501" target=_blank>Cours INGInious sur la programmation Légo</a></p></li>
<li><p><a href="http://isn.codelab.info/site/assets/files/1637/guide_nxt.pdf" target=_blank>Manuel de l’utilisateur NXT</a></p></li>
<li><p><a href="http://www.lejos.org/rcx/tutorial/index.html" target=_blank>The leJOS NXJ Tutorial.</a> </p></li>
<li><p><a href="http://lejos.sourceforge.net/nxt/nxj/api/index.html" target=_blank>The leJOS NXJ API.</a> </p></li>
<li><p>Pour un exemple complet, voir le programme SimpleController sur <a href="https://github.com/UCL-INGI/Projet-P1" target=_blank>GitHub</a></p></li>
</ol>
      </section>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
