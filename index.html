<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Projet P1 - Partie Informatique by NDetienne</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Projet P1 - Partie Informatique</h1>
        <p></p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/NDetienne/ProjetP1" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/NDetienne/ProjetP1/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/NDetienne/ProjetP1/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a id="1-comment-programmer-son-robot" class="anchor" href="#1-comment-programmer-son-robot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1) Comment programmer son robot :</h1>

<p>La librairie concernant le fonctionnement des robots Lego est détaillée à <a href="http://lejos.sourceforge.net/nxt/nxj/api/index.html">cette page</a>.
Celle-ci contient de nombreuses classes spécifiques aux fonctionnalités du NXT, groupées dans les packages dont le nom commence par « lejos » (n’oubliez pas les « import » correspondants dans votre programme !). Ce tutoriel n'a pas pour but de détailler toutes les possibilités de ces classes, mais donne un aperçu succinct et partiel des possibilités offertes par ces classes et méthodes.</p>

<h1>
<a id="2-les-senseurs-" class="anchor" href="#2-les-senseurs-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2) Les senseurs :</h1>

<p>La classe <strong>lejos.nxt.SensorPort</strong> représente un un port d’entrée du NXT. Il y a quatre instances prédéfinies de la classe <strong>SensorPort</strong>, correspondant aux quatre ports d'entrée : <strong>SensorPort.S1</strong>, <strong>SensorPort.S2</strong>, <strong>SensorPort.S3</strong> et <strong>SensorPort.S4</strong>. 
Il existe également une classe correspondant à chaque type de senseur : </p>

<ul>
<li>Capteur tactile : classe <strong>lejos.nxt.TouchSensor</strong>
</li>
<li>Capteur sonore : classe <strong>lejos.nxt.SoundSensor</strong>
</li>
<li>Capteur photosensible : classe <strong>lejos.nxt.LightSensor</strong>
</li>
<li>Capteur de distance à ultrasons : classe <strong>lejos.nxt.UltrasonicSensor</strong>
</li>
</ul>

<p>Le constructeur de chacune de ces classes prend comme paramètre le <strong>SensorPort</strong> auquel le senseur est connecté. Chaque classe fournit une ou plusieurs méthodes permettant de lire la mesure du senseur correspondant. </p>

<p>Exemple :</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.*</span>; 
<span class="pl-smi">UltrasonicSensor</span> sonic <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">UltrasonicSensor</span>(<span class="pl-smi">SensorPort</span><span class="pl-c1"><span class="pl-k">.</span>S1</span>); <span class="pl-c">// capteur à ultrasons connecté au port S1. </span>
<span class="pl-smi">TouchSensor</span> touch <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TouchSensor</span>(<span class="pl-smi">SensorPort</span><span class="pl-c1"><span class="pl-k">.</span>S2</span>);           <span class="pl-c">// capteur tactile connecté au port S2. </span>
<span class="pl-k">if</span> (touch<span class="pl-k">.</span>isDown()) {                                        <span class="pl-c">// si le capteur tactile est touché,</span>
          <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> <span class="pl-k">+</span> sonic<span class="pl-k">.</span>getDistance());      <span class="pl-c">// affiche la distance vue par le capteur à ultrasons </span>
} </pre></div>

<h1>
<a id="3-les-moteurs-" class="anchor" href="#3-les-moteurs-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3) Les moteurs :</h1>

<p>La classe <strong>lejos.nxt.Motor</strong> permet d'accéder aux moteurs NXT. Elle fournit trois instances prédéfinies (de type <strong>NXTRegulatedMotor</strong>), correspondant aux trois ports de sortie du NXT : <strong>Motor.A</strong>, <strong>Motor.B</strong> et <strong>Motor.C</strong>.
La classe <strong>NXTRegulatedMotor</strong> représente un moteur. La méthode <strong>setSpeed</strong> permet d’ajuster la vitesse du moteur. Les moteurs NXT sont équipés d’un capteur de rotation intégré (tachymètre) qui permet d’offrir une large palette de méthodes différentes. Les méthodes <strong>getTachoCount</strong> et <strong>resetTachoCount</strong> permettent de lire et de remettre à zéro le compteur de rotation. Les autres méthodes, telles que <strong>rotate</strong>, utilisent également ce compteur pour contrôler précisément le nombre de rotations du moteur. 
Les mouvements du moteur s'effectuent à leur vitesse propre, distincte de (et beaucoup plus lente que) la vitesse d'exécution du programme Java. Il existe deux types de méthodes permettant de commander le mouvement du moteur. </p>

<p>Il s'agit des <strong>méthodes bloquantes</strong> et des <strong>méthodes non-bloquantes</strong> : </p>

<p>• Pour une <strong>méthode bloquante</strong>, l'amplitude du mouvement (nombre de degrés, de tours, distance, ...) est pré-déterminée et la méthode attend jusqu'à la fin du mouvement (exemple : <strong>Motor.A.rotate(90)</strong>). Durant ce temps, l'exécution du programme est suspendue; il ne peut pas, par exemple, détecter un obstacle et arrêter prématurément le mouvement. </p>

<p>Les <strong>méthodes bloquantes</strong> <strong>rotate</strong> et <strong>rotateTo</strong> font tourner le moteur d'un angle donné ou jusqu'à un angle donné. Lorsque la rotation demandée est terminée, le programme passe à l'instruction suivante. </p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.*</span>; 
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>setSpeed(<span class="pl-c1">720</span>);   <span class="pl-c">// 2 rotations complètes par seconde.</span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>resetTachoCount(); <span class="pl-c">// Remettre le compteur à zéro</span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>rotate(<span class="pl-c1">90</span>);      <span class="pl-c">// Faire tourner le moteur d'1/4 tour.</span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>rotateTo(<span class="pl-c1">720</span>);   <span class="pl-c">// Faire tourner le moteur jusqu'à ce que le compteur atteigne 2 tours. </span>
<span class="pl-k">int</span> angle <span class="pl-k">=</span> <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>getTachoCount();  <span class="pl-c">//Lire le compteur.</span></pre></div>

<p>• Une méthode est <strong>non-bloquante</strong> lorsque la méthode démarre le mouvement et se termine immédiatement, alors que le mouvement se poursuit (exemple <strong>Motor.A.forward()</strong>). Le programme doit donc lui-même arrêter les moteurs en temps opportun, soit après un certain délai (<strong>Thread.sleep(xx)</strong>), soit lorsqu'une condition est vérifiée. En attendant, le programme doit absolument libérer le processeur (<strong>Thread.yield()</strong>), pour permettre aux autres tâches de s'exécuter. 
Les méthodes non-bloquantes <strong>forward()</strong> et <strong>backward()</strong> démarrent le moteur en marche avant ou arrière et passent tout de suite à l'instruction suivante. Les méthodes <strong>flt()</strong> et <strong>stop()</strong> permettent d'arrêter le moteur. <strong>stop()</strong> empêche le moteur de tourner tandis que <strong>flt()</strong> le laisse « flotter » librement.</p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>resetTachoCount();       <span class="pl-c">// Remettre le compteur à zéro </span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>forward();              <span class="pl-c">// Démarrer le moteur en avant. </span>
<span class="pl-smi">Thread</span><span class="pl-k">.</span>sleep(<span class="pl-c1">1000</span>);             <span class="pl-c">// Attendre 1 seconde tout en roulant </span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>stop();                 <span class="pl-c">// Arrêter de moteur. </span>
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>backward();             <span class="pl-c">// Démarrer le moteur en arrière. </span>
<span class="pl-k">while</span> (<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>getTachoCount() <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {  <span class="pl-c">// Tant que le compteur ne revient pas à 0... </span>
         <span class="pl-smi">Thread</span><span class="pl-k">.</span>yield();        <span class="pl-c">// Libérer le processeur. </span>
} 
<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>stop();                 <span class="pl-c">// Arrêter de moteur. </span></pre></div>

<p>Plusieurs méthodes bloquantes proposent une variante non-bloquante, comme par exemple <strong>rotate()</strong> et <strong>rotateTo()</strong> (voir ci-dessous). La méthode <strong>isMoving()</strong> permet de tester si le moteur tourne toujours.</p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>rotate(<span class="pl-c1">360</span><span class="pl-k">*</span><span class="pl-c1">10</span>, <span class="pl-c1">true</span>); <span class="pl-c">// Démarrer le moteur pour 10 tours. </span>
<span class="pl-k">while</span> (<span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>isMoving()) {  <span class="pl-c">// Tant que le moteur tourne... </span>
      <span class="pl-k">int</span> angle <span class="pl-k">=</span> <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span><span class="pl-k">.</span>getTachoCount();      <span class="pl-c">// Lire le compteur... </span>
      <span class="pl-c1">LCD</span><span class="pl-k">.</span>drawInt(angle,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>);                  <span class="pl-c">// et l'afficher. </span>
} </pre></div>

<h1>
<a id="4-pilotage-dun-robot-roulant-" class="anchor" href="#4-pilotage-dun-robot-roulant-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4) Pilotage d'un robot roulant :</h1>

<p>La classe <strong>lejos.robotics.navigation.DifferentialPilot</strong> permet de piloter un robot roulant avec deux roues sur un même axe contrôlées par deux moteurs séparés (châssis de type « chaise roulante ») et une roue libre dite « folle »: 
Les constructeurs permettent de déclarer la géométrie du châssis. Les paramètres de distance peuvent être dans une unité quelconque, pourvu que cette unité soit la même dans tout le programme.</p>

<p>Exemple (pour un robot dont les roues gauche et droite sont sur les moteurs A et C) : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.*</span>; 
<span class="pl-k">import</span> <span class="pl-smi">lejos.robotics.navigation.*</span>; 

<span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">DIAM_ROUE</span> <span class="pl-k">=</span> <span class="pl-c1">2.1f</span>;   <span class="pl-c">// Diamètre des roues motrices en cm</span>
<span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">DIST_ROUE</span> <span class="pl-k">=</span> <span class="pl-c1">4.4f</span>;   <span class="pl-c">// Distance entre les roues motrices en cm</span>
<span class="pl-smi">DifferentialPilot</span> pilot <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">DifferentialPilot</span>(<span class="pl-c1">DIAM_ROUE</span>, <span class="pl-c1">DIST_ROUE</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">C</span>); 
pilot<span class="pl-k">.</span>setTravelSpeed(<span class="pl-c1">10</span>);        <span class="pl-c">// Vitesse du robot = 10 cm/s. </span>
pilot<span class="pl-k">.</span>setRotateSpeed(<span class="pl-c1">45</span>);        <span class="pl-c">// Vitesse de pivotage = 45 degrés/s. </span></pre></div>

<p>Les méthodes (bloquantes) <strong>travel(xx)</strong>, <strong>travelArc(xx)</strong> et <strong>rotate(xx)</strong> permettent ensuite de faire se déplacer le robot en ligne droite, selon un arc de cercle ou de le faire pivoter sur lui même. </p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre>pilot<span class="pl-k">.</span>travel(<span class="pl-c1">12</span>);                <span class="pl-c">// Avancer de 12 cm.</span>
pilot<span class="pl-k">.</span>rotate(<span class="pl-k">-</span><span class="pl-c1">90</span>);               <span class="pl-c">// Pivoter de 90 degrés vers la gauche.</span>
pilot<span class="pl-k">.</span>travel(<span class="pl-k">-</span><span class="pl-c1">12</span>);               <span class="pl-c">// Reculer de 12 cm.</span>
pilot<span class="pl-k">.</span>travelArc(<span class="pl-c1">10</span>, <span class="pl-c1">12</span>);         <span class="pl-c">// Faire un virage à gauche de 12 cm de long selon un rayon de 10 cm.</span>
pilot<span class="pl-k">.</span>arc(<span class="pl-k">-</span><span class="pl-c1">10</span>, <span class="pl-c1">90</span>);              <span class="pl-c">// Faire un virage à droite de 90 degrés selon un rayon de 10 cm.</span></pre></div>

<p>Les méthodes (non-bloquantes) <strong>forward()</strong>, <strong>backward()</strong>, <strong>arcForward()</strong>, <strong>arcBackward()</strong> et <strong>stop()</strong> permettent de démarrer et d'arrêter le robot pour une durée indéterminée.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-java"><pre>pilot<span class="pl-k">.</span>forward();        <span class="pl-c">// Avancer en ligne droite indéfiniment. </span>
<span class="pl-k">while</span>(<span class="pl-k">!</span><span class="pl-smi">Button</span><span class="pl-c1"><span class="pl-k">.</span>ENTER</span><span class="pl-k">.</span>isDown()) { <span class="pl-c">// Tant que le bouton orange n'est pas pressé...</span>
       <span class="pl-smi">Thread</span><span class="pl-k">.</span>yield();           <span class="pl-c">// Libérer le processeur. </span>
} 
pilot<span class="pl-k">.</span>stop();           <span class="pl-c">// Arrêter le robot. </span></pre></div>

<h1>
<a id="5-contrôle-par-tâches-" class="anchor" href="#5-contr%C3%B4le-par-t%C3%A2ches-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5) Contrôle par tâches :</h1>

<p>Un programme de contrôle de robot doit être réactif : il doit pouvoir adapter son comportement en fonction de l'évolution du monde physique dans lequel il évolue (repères extérieurs, obstacles, vitesse des moteurs, etc.). Réaliser un tel programme sous forme d'une cascade de conditions et de boucles peut paraître simple et intuitif mais conduit rapidement à du « code spaghetti » : un enchevêtrement inextricable de cas particuliers, difficile à lire, à maintenir et à mettre au point. Il est possible d'utiliser un mécanisme de listeners, mais ceci conduit à des difficultés techniques et est découragé par les concepteurs de Lejos eux-mêmes. 
Au lieu de cela, le package lejos.robotics.subsumption fournit une architecture de contrôle par tâches qui permet de réaliser un programme réactif de manière modulaire. Le principe est de décomposer le programme en plusieurs tâches qui sont exécutées au besoin, en respectant un ordre de priorité, plutôt que de manière prédéterminée par le programme. Ceci permet de caractériser clairement chaque aspect du comportement, et d'ajouter facilement des tâches supplémentaires.</p>

<p>Par exemple, un contrôleur de robot pourrait avoir les tâches suivantes : </p>

<ol>
<li><p>avancer en ligne droite </p></li>
<li><p>si un obstacle est détecté, virer d'un quart de tour vers la gauche </p></li>
<li><p>si un bouton est pressé, s'arrêter et mettre fin au programme. </p></li>
</ol>

<p>Ces tâches sont en ordre croissant de priorité : la tâche 1 s'exécutant tant que les autres tâches (plus prioritaires) ne sont pas activées.</p>

<h2>
<a id="51-définir-une-tâche" class="anchor" href="#51-d%C3%A9finir-une-t%C3%A2che" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.1) Définir une tâche</h2>

<p>Chaque tâche est définie par trois éléments, spécifiés par trois méthodes de l'interface Behavior : </p>

<p>• la méthode <strong>takeControl()</strong> fournit la condition d'activation qui détermine quand cette tâche doit être initiée. On peut vouloir qu'une action soit activée si un obstacle se trouve à moins de 25cm (voir exemple ci-dessous), ou si le capteur de tactile est pressé. On peut également vérifier des conditions multiples. Exemple : La tâche est activée si, à la fois le capteur photosensible détecte une ligne noire, ET si la valeur booléenne d'une variable est à true. Pour que la tâche soit activée, il faut que la valeur retournée par la méthode <strong>takecontrol()</strong> soit <strong>true</strong>. </p>

<p>• la méthode <strong>action()</strong> définit l'action que cette tâche doit accomplire (voir exemple ci-dessous). Cette méthode est appelée dès que la tâche devient active. </p>

<p>• la méthode <strong>suppress()</strong> permet la suppression (l'arrêt) de l'action en cours d'exécution. Elle permet aussi de mettre à jour des données avant la fin de la tâche. Elle est appelée par l'<strong>Arbitrator</strong> sur la tâche en cours si la méthode <strong>takeControl()</strong> d'une tâche plus prioritaire retourne <strong>true</strong>. Si cette tâche arrêtée est réactivée plus tard durant l'exéction du programme, la méthode action sera exécutée depuis le début et non depuis l'endroit où elle avait été arrêtée précédemment.  </p>

<p>Pour définir une tâche, il faut réaliser une implémentation de cette interface définissant ces trois méthodes. Il s'agit d'une forme de programmation événementielle : on fournit au système de contrôle du robot différentes tâches à exécuter lorsque différents événements surviennent. Par exemple, la tâche suivante effectue une manoeuvre lorsqu'un obstacle est détecté par le senseur à ultrasons (sonar) : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">lejos.robotics.navigation.DifferentialPilot</span>; 
<span class="pl-k">import</span> <span class="pl-smi">lejos.robotics.subsumption.Behavior</span>; 
<span class="pl-k">import</span> <span class="pl-smi">lejos.nxt.UltrasonicSensor</span>; 

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EviterBehavior</span> <span class="pl-k">implements</span> <span class="pl-e">Behavior</span> { 
    <span class="pl-k">private</span> <span class="pl-k">boolean</span> suppressed <span class="pl-k">=</span> <span class="pl-c1">false</span>; 
    <span class="pl-k">private</span> <span class="pl-smi">DifferentialPilot</span> pilote; 
    <span class="pl-k">private</span> <span class="pl-smi">UltrasonicSensor</span> sonar; 

    <span class="pl-k">public</span> <span class="pl-en">EviterBehavior</span>(<span class="pl-smi">DifferentialPilot</span> <span class="pl-v">pilote</span>, <span class="pl-smi">UltrasonicSensor</span> <span class="pl-v">sonar</span>) { 
        <span class="pl-v">this</span><span class="pl-k">.</span>pilote <span class="pl-k">=</span> pilote; 
        <span class="pl-v">this</span><span class="pl-k">.</span>sonar <span class="pl-k">=</span> sonar; 
    } 
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">action</span>() { 
        suppressed <span class="pl-k">=</span> <span class="pl-c1">false</span>;                     <span class="pl-c">// Remise à zéro  </span>
        pilote<span class="pl-k">.</span>arc(<span class="pl-c1">20.0</span>, <span class="pl-k">-</span><span class="pl-c1">90.0</span>, <span class="pl-c1">true</span>);          <span class="pl-c">// Entame un virage arrière sans attendre la fin. </span>
        <span class="pl-k">while</span> (<span class="pl-k">!</span>suppressed <span class="pl-k">&amp;&amp;</span> pilote<span class="pl-k">.</span>isMoving()) {  <span class="pl-c">// Tant que {suppress} n'a pas été  appelé et que le virage n'est pas terminé... </span>
            <span class="pl-smi">Thread</span><span class="pl-k">.</span>yield();     <span class="pl-c">// libérer le processeur </span>
        } 
        pilote<span class="pl-k">.</span>stop();      <span class="pl-c">// Arrêter le robot </span>
    } 
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">suppress</span>() { 
        suppressed <span class="pl-k">=</span> <span class="pl-c1">true</span>; 
    } 
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">takeControl</span>() {  
        <span class="pl-c">// Activer si un obstacle à moins de 25 cm </span>
        <span class="pl-k">return</span> sonar<span class="pl-k">.</span>getDistance() <span class="pl-k">&lt;</span> <span class="pl-c1">25</span>; 
    } 
} </pre></div>

<p>Attention au mécanisme de suppression de tâche ! La méthode suppress est exécutée alors que la méthode action est elle-même toujours en cours d'exécution. Elle n'arrête pas simplement la tâche en cours; au lieu de cela, elle doit signaler à la méthode action que celle-ci doit d'elle-même interrompre son activité. Pour assurer cette synchronisation, on utilise une variable d'instance suppressed comme suit : </p>

<p>• La méthode <strong>action()</strong> met la variable suppressed à false initialement, </p>

<p>• La méthode <strong>suppress()</strong>, lorsqu'elle est appelée, met la variable suppressed à true, </p>

<p>• La méthode <strong>action()</strong> surveille continuellement la variable suppressed via la condition de boucle. </p>

<p>Si la variable <strong>suppressed</strong> devient <strong>true</strong> (indiquant que la méthode suppress a été exécutée), le mouvement en cours est interrompu (pilote.stop()) et la méthode retourne immédiatement. La méthode doit donc utiliser des méthodes non-bloquantes sous peine d'ajouter un délai avant la prise en compte du passage de la variable à true. </p>

<p>La suppression (interruption) de la tâche n'est nécessaire que si action perdure dans le temps ; si elle se termine immédiatement il n'est pas nécessaire de mettre en place un mécanisme pour la supprimer. Par exemple, l'action de la tâche suivante quittant immédiatement le programme il est inutile de prévoir sa suppression. </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">StopBehavior</span> <span class="pl-k">implements</span> <span class="pl-e">Behavior</span> { 
    <span class="pl-k">private</span> <span class="pl-smi">DifferentialPilot</span> pilote; 

    <span class="pl-k">public</span> <span class="pl-en">StopBehavior</span>(<span class="pl-smi">DifferentialPilot</span> <span class="pl-v">pilote</span>) { 
        <span class="pl-v">this</span><span class="pl-k">.</span>pilote <span class="pl-k">=</span> pilote; 
    } 

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">action</span>() { 
        pilote<span class="pl-k">.</span>stop();      <span class="pl-c">// Arrêter le robot.</span>
        <span class="pl-smi">System</span><span class="pl-k">.</span>exit(<span class="pl-c1">0</span>);         <span class="pl-c">// Quitter le programme. </span>
    } 

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">suppress</span>() {    <span class="pl-c">// Rien à supprimer.</span>
    } 

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">takeControl</span>() {  
        <span class="pl-c">// Activer si le bouton ESCAPE est pressé. </span>
        <span class="pl-k">return</span> <span class="pl-smi">Button</span><span class="pl-c1"><span class="pl-k">.</span>ESCAPE</span><span class="pl-k">.</span>isDown(); 
    } 
} </pre></div>

<h2>
<a id="53-créer-un-contrôleur" class="anchor" href="#53-cr%C3%A9er-un-contr%C3%B4leur" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.3) Créer un contrôleur</h2>

<p>La classe <strong>Arbitrator</strong> permet de construire et d'activer un contrôleur par tâches. Son constructeur prend en paramètre un tableau contenant les tâches que le robot sera succeptible d'effectuer et que l'<strong>Arbitrator</strong> devra gérer. Les tâches doivent être ordonnées par ordre croissant de priorité. La méthode <strong>start()</strong> permet d'activer l'<strong>Arbitrator</strong>. </p>

<p>Exemple : </p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">DifferentialPilot</span> pilote <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">DifferentialPilot</span>(<span class="pl-c1">DIAM_ROUE</span>, <span class="pl-c1">DIST_ROUE</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">A</span>, <span class="pl-smi">Motor</span><span class="pl-k">.</span><span class="pl-smi">C</span>); 
<span class="pl-smi">UltrasonicSensor</span> sonar <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">UltrasonicSensor</span>(<span class="pl-smi">SensorPort</span><span class="pl-c1"><span class="pl-k">.</span>S1</span>);

<span class="pl-smi">Behavior</span> avancer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">AvancerBehavior</span>(pilote);         <span class="pl-c">// Tâche avancer (tout droit indéfiniment).</span>
<span class="pl-smi">Behavior</span> eviter <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">EviterBehavior</span>(pilote, sonar); <span class="pl-c">// Tâche eviter (manoeuvre arrière en cas d'obstacle).</span>
<span class="pl-smi">Behavior</span> stop <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StopBehavior</span>(pilote);            <span class="pl-c">// Tâche stop (arrêter tout si un bouton est appuyé). </span>
<span class="pl-k">Behavior</span>[] taches <span class="pl-k">=</span> { avancer, eviter, stop };       <span class="pl-c">// Tableau de tâches dans l'ordre croissant de priorité.</span>
<span class="pl-smi">Arbitrator</span> arbitre <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Arbitrator</span>(taches); 
arbitre<span class="pl-k">.</span>start(); </pre></div>

<p>Une tâche ne sera activée que si elle est plus prioritaire que la tâche en cours, et pourra être interrompue par une tâche plus prioritaire qu'elle. L'activation et l'interruption d'une tâche ne peut avoir lieu qu'au moment où la tâche en cours exécute une méthode non bloquante. Simultanément, le contrôleur évalue en permanence les méthodes <strong>takeControl()</strong> de la liste des tâches et initie la tâche la plus prioritaire pour laquelle <strong>takeControl()</strong> retourne <strong>true</strong>, en appelant au besoin suppress pour supprimer la tâche en cours (moins prioritaire). 
Attention : le bon fonctionnement de ce mécanisme dépend du fait que la méthode action() de chaque tâche se termine rapidement lorsque <strong>suppress()</strong> est appelée. A tout moment, une seule tâche est activée ; une nouvelle tâche ne peut s'enclencher que lorsque la tâche en cours s'interrompt. Pour ce faire, le contrôleur appelle uniquement <strong>suppress()</strong> de la tâche en cours (moins prioritaire), puis appelle <strong>action()</strong> de la tâche à activer. Il ne peut pas forcer l'arrêt de l'exécution de action. Il est donc important de bien appliquer le mécanisme de suppression des tâches décrit précédemment. </p>

<h1>
<a id="6-remarques-et-conseils" class="anchor" href="#6-remarques-et-conseils" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6) Remarques et conseils:</h1>

<p>Un exemple complet nommé <strong>SimpleController</strong>, dont sont tirés les extraits présentés ici, est disponible sur le site du cours d'informatique. Utilisez-le comme point de départ. 
Respectez bien les recommandations concernant la synchronisation, pour éviter des problèmes de blocages et de conflits difficiles à diagnostiquer : </p>

<p>• Soyez attentifs à la différence entre méthodes bloquantes et non-bloquantes. </p>

<p>• Utilisez yield et/ou sleep à bon escient pour ne pas accaparer le processeur. </p>

<p>• Utilisez une variable de synchronisation pour la suppression des tâches, et assurez-vous que vos tâches s'interrompent bien lorsque demandé. </p>

<p>Il est prudent d'avoir comme tâche de plus haute priorité une tâche d'arrêt d'urgence conditionnée sur un bouton du robot (par exemple la tâche StopBehavior de l'exemple fourni). 
Les senseurs, moteurs et pièces mécaniques appartiennent au domaine de la physique : leur précision peut donc varier, une étape de calibrage peut être nécessaire... </p>

<h1>
<a id="7-documentation-" class="anchor" href="#7-documentation-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7) Documentation :</h1>

<p>Ces documents sont disponibles ou référencés sur le site du cours d'informatique (FSAB1401). </p>

<ol>
<li><p>Manuel de l’utilisateur NXT (version Lego Minstorms Education). The Lego Group, 2006.  </p></li>
<li><p><a href="http://lejos.sourceforge.net/nxt/nxj/tutorial/index.htm">The leJOS NXJ Tutorial.</a> </p></li>
<li><p><a href="http://lejos.sourceforge.net/nxt/nxj/api/index.html">The leJOS NXJ API.</a> </p></li>
<li><p>Pour un exemple complet, voir SimpleController sur Moodle </p></li>
</ol>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/NDetienne">NDetienne</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
