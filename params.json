{
  "name": "Projet P1 - Partie Informatique",
  "tagline": "",
  "body": "# 1) Le matériel :\r\nLa « brique » NXT fabriquée par Lego est la nouvelle version du système Lego Mindstorms. \r\nElle est dotée d’un microprocesseur ARM7 32 bits avec 256 ko de mémoire flash, dont 64 ko de mémoire vive (RAM).\r\n\r\n![brique](https://github.com/UCL-INGI/Projet-P1/blob/gh-pages/images/manuel/brique.png)\r\n\r\nLe NXT est équipé de connexion sans fil Bluetooth (classe II V2.0) et d'un port USB 2.0. \r\nCes connexions permettent au NXT de se connecter facilement aux PCs avec un haut débit de transfert de données. \r\nPour son alimentation, le NXT a une batterie lithium rechargeable et peut également fonctionner sur six piles AA. \r\n\r\n![alim](https://github.com/UCL-INGI/Projet-P1/blob/gh-pages/images/manuel/Xaejjj.png)\r\n\r\nPour sa partie robotique, le NXT possède : \r\nquatre ports d’entrée (1 à 4) destinées à la connexion de capteurs (il y a quatre types de capteurs : capteur tactile, capteur sonore, capteur photosensible et capteur d’ultrasons), \r\ntrois ports de sortie (A, B, C) où des moteurs et des lampes peuvent être branchés. \r\n\r\nOn peut contrôler le NXT par quatre boutons : \r\nBouton orange : pour allumer, valider ou démarrer un programme. \r\nBoutons flèches gris clairs : pour déplacer le curseur ou la sélection (monter ou descendre dans les menus). \r\nBouton gris foncé : pour éteindre ou retourner en arrière. \r\n\r\nEn outre, le NXT est doté d’un haut-parleur et peut produire des sons à une fréquence de 8 kHz. \r\n\r\n\r\n# 2) Le logiciel :\r\nDans le cadre du projet, vous allez écrire des programmes en Java pour piloter votre robot. LeJOS NXJ est un environnement de programmation Java pour le Lego Mindstorms NXJ. Pour utiliser LeJOS NXJ, on installe une extension NXJ dans BlueJ. \r\n* Cette extension ajoute un sous-menu qui permet de compiler et de télécharger les programmes Java dans le NXT. \r\n* Les programmes Java pour le NXT doivent être écrits et compilés sur un PC avant d'être téléchargés dans la mémoire du NXT. \r\n* Après avoir préparé les programmes sur le PC, on peut les télécharger dans NXT par la connexion (voir plus bas pour le téléchargement). \r\n* Une fois que les programmes sont chargés dans le mémoire de NXT, on peut choisir un programme (en utilisant les boutons de flèches) et le lancer avec le bouton orange. \r\n\r\n# 3) Bluej:\r\n## 1) Démarrer Bluej dans les salles Barb:\r\nTODO\r\n\r\n## 2) Démarrer Bluej dans les salles Candix (DAO/IAO...):\r\nTODO\r\n\r\n## 3) Installation sur votre portable:\r\nTODO\r\n\r\n## 4) Tester l'installation et le robot sur base d'un exemple:\r\nAfin de tester, à la fois l'installation de l'extension et le matériel que vous avez reçu vous pouvez télécharger le programme de test (SimpleControler) présent sur gitHub.  \r\n* Téléchargez et décompressez l'archive dans un nouveau répertoire (exemple : /home/VOTRE_LOGIN/Documents/Projet-P1/) \r\n* Ouvrez le projet SimpleController dans Bluej (Project – Open Project – SimpleController ).\r\n* Compilez-le : clic droit sur la classe principale, possédant la méthode main (SimpleController dans ce cas-ci) et sélectionnez  NXJ  - NXJ-Compile . Ceci aura généré un fichier dont l'extension est « .nxj ».\r\n\r\n![alim](https://github.com/UCL-INGI/Projet-P1/blob/gh-pages/images/manuel/bluej1.png)\r\n\r\n![alim](https://github.com/UCL-INGI/Projet-P1/blob/gh-pages/images/manuel/bluej2.png)\r\n\r\nEn cas d'erreur, vérifiez la configuration de Bluej :\r\nTools – Preferences – Librairies : il doit y avoir le **classes.jar** et il doit être dans le status **loaded**. Si ce n'est pas le cas, il faut l'ajouter (path = /opt/leJOS_NXJ/lib/nxt/classes.jar) et redémarrer Bluej.\r\nDans Tools – Preferences – Extensions la variable **NXJ_HOME** doit être égale à **/opt/leJOS_NXJ**\r\n\r\n\r\n## 5) Télécharger le programme dans le robot:\r\n\r\n* Connectez le boitier NXT à l'ordinateur par le câble USB\r\n* Allumez-le (branchez-le également sur le secteur au besoin)\r\n* Poussez le programme sur le robot : clic droit sur la classe principale et sélectionnez NXJ  - NXJ-UploadUSB. Attention, le boitier doit être allumé pendant le transfert !\r\n* Si aucun message d'erreur ne s'affiche le programme est chargé dans le robot.\r\n\r\n![alim](https://github.com/UCL-INGI/Projet-P1/blob/gh-pages/images/manuel/upload1.png)\r\n\r\n* Débranchez le câble USB et naviguez dans le menu du robot « Files » jusqu'à retrouver le programme SimpleController. Vous pouvez à présent l'exécuter « Execute Program » (branchez les moteurs et capteurs comme décrit dans le code afin de tester son fonctionnement).\r\n\r\n![alim](https://github.com/UCL-INGI/Projet-P1/blob/gh-pages/images/manuel/upload2.png)\r\n\r\n\r\n# 4) Comment programmer son robot :\r\nLa librairie concernant le fonctionnement des robots Lego est détaillée à [cette page](http://lejos.sourceforge.net/nxt/nxj/api/index.html ).\r\nCelle-ci contient de nombreuses classes spécifiques aux fonctionnalités des Lego Minstorms, groupées dans les packages dont le nom commence par « lejos » (n’oubliez pas les « import » correspondants dans votre programme !). Ce tutoriel n'a pas pour but de détailler toutes les possibilités de ces classes, mais donne un aperçu succinct et partiel des possibilités offertes par ces classes et méthodes. Ce qui suit est donc une entrée en matière suffisante pour la réalisation du projet P1.\r\n\r\n\r\n## 1) Les senseurs :\r\nLa classe **lejos.nxt.SensorPort** représente un port d’entrée du NXT. Il y a quatre instances prédéfinies de la classe **SensorPort**, correspondant aux quatre ports d'entrée : **SensorPort.S1**, **SensorPort.S2**, **SensorPort.S3** et **SensorPort.S4**. \r\nIl existe également une classe correspondant à chaque type de senseur : \r\n- Capteur tactile : classe **lejos.nxt.TouchSensor**\r\n- Capteur sonore : classe **lejos.nxt.SoundSensor**\r\n- Capteur photosensible : classe **lejos.nxt.LightSensor**\r\n- Capteur de distance à ultrasons : classe **lejos.nxt.UltrasonicSensor**\r\n\r\nLe constructeur de chacune de ces classes prend comme paramètre le **SensorPort** auquel le senseur est connecté. Chaque classe fournit une ou plusieurs méthodes permettant de lire la mesure du senseur correspondant. \r\n\r\nExemple :\r\n```java\r\nimport lejos.nxt.*; \r\nUltrasonicSensor sonic = new UltrasonicSensor(SensorPort.S1); // capteur à ultrasons connecté au port S1. \r\nTouchSensor touch = new TouchSensor(SensorPort.S2);           // capteur tactile connecté au port S2. \r\nif (touch.isDown()) {                                        // si le capteur tactile est touché,\r\n          System.out.println(\" \" + sonic.getDistance());      // affiche la distance vue par le capteur à ultrasons \r\n} \r\n```\r\n\r\n## 2) Les moteurs :\r\nLa classe **lejos.nxt.Motor** permet d'accéder aux moteurs NXT. Elle fournit trois instances prédéfinies (de type **NXTRegulatedMotor**), correspondant aux trois ports de sortie du NXT : **Motor.A**, **Motor.B** et **Motor.C**.\r\nLa classe **NXTRegulatedMotor** représente un moteur. La méthode **setSpeed** permet d’ajuster la vitesse du moteur. Les moteurs NXT sont équipés d’un capteur de rotation intégré (tachymètre) qui permet d’offrir une large palette de méthodes différentes. Les méthodes **getTachoCount()** et **resetTachoCount()** permettent de lire et de remettre à zéro le compteur de rotation. Les autres méthodes, telles que **rotate()**, utilisent également ce compteur pour contrôler précisément le nombre de rotations du moteur. \r\nLes mouvements du moteur s'effectuent à leur vitesse propre, distincte de (et beaucoup plus lente que) la vitesse d'exécution du programme Java. Il existe deux types de méthodes permettant de commander le mouvement du moteur. \r\n\r\nIl s'agit des **méthodes bloquantes** et des **méthodes non-bloquantes** : \r\n\r\n• Pour une **méthode bloquante**, l'amplitude du mouvement (nombre de degrés, de tours, distance, ...) est pré-déterminée et la méthode attend jusqu'à la fin du mouvement (exemple : **Motor.A.rotate(90)**). Durant ce temps, l'exécution du programme est suspendue; il ne peut pas, par exemple, détecter un obstacle et arrêter prématurément le mouvement. \r\n\r\nLes **méthodes bloquantes** **rotate()** et **rotateTo(...)** font tourner le moteur d'un angle donné ou jusqu'à un angle donné. Lorsque la rotation demandée est terminée, le programme passe à l'instruction suivante. \r\n\r\nExemple : \r\n```java\r\nimport lejos.nxt.*; \r\nMotor.A.setSpeed(720); \t // 2 rotations complètes par seconde.\r\nMotor.A.resetTachoCount(); // Remettre le compteur à zéro\r\nMotor.A.rotate(90); \t // Faire tourner le moteur d'1/4 tour.\r\nMotor.A.rotateTo(720); \t // Faire tourner le moteur jusqu'à ce que le compteur atteigne 2 tours. \r\nint angle = Motor.A.getTachoCount();  //Lire le compteur.\r\n```\r\n\r\n• Une méthode est **non-bloquante** lorsque la méthode démarre le mouvement et se termine immédiatement, alors que le mouvement se poursuit (exemple **Motor.A.forward()**). Le programme doit donc lui-même arrêter les moteurs en temps opportun, soit après un certain délai (**Thread.sleep(...)**), soit lorsqu'une condition est vérifiée. En attendant, le programme doit absolument libérer le processeur (**Thread.yield()**), pour permettre aux autres tâches de s'exécuter. \r\nLes méthodes non-bloquantes **forward()** et **backward()** démarrent le moteur en marche avant ou arrière et passent tout de suite à l'instruction suivante. Les méthodes **flt()** et **stop()** permettent d'arrêter le moteur. La méthode **stop()** empêche le moteur de tourner tandis que **flt()** le laisse « flotter » librement.\r\n\r\nExemple : \r\n```java\r\nMotor.A.resetTachoCount();       // Remettre le compteur à zéro \r\nMotor.A.forward();              // Démarrer le moteur en avant. \r\nThread.sleep(1000);             // Attendre 1 seconde tout en roulant \r\nMotor.A.stop();                 // Arrêter de moteur. \r\nMotor.A.backward();             // Démarrer le moteur en arrière. \r\nwhile (Motor.A.getTachoCount() > 0) {  // Tant que le compteur ne revient pas à 0... \r\n         Thread.yield();        // Libérer le processeur. \r\n} \r\nMotor.A.stop();                 // Arrêter de moteur. \r\n```\r\n\r\nPlusieurs méthodes bloquantes sont proposées avec une variante non-bloquante, comme par exemple **rotate(..)** et **rotateTo(...)** en ajoutant **true** comme argument  (voir ci-dessous). La méthode **isMoving()** permet de tester si le moteur tourne toujours.\r\n\r\nExemple : \r\n```java\r\nMotor.A.rotate(360*10, true); // Démarrer le moteur pour 10 tours. \r\nwhile (Motor.A.isMoving()) {  // Tant que le moteur tourne... \r\n      int angle = Motor.A.getTachoCount();      // Lire le compteur... \r\n      LCD.drawInt(angle,0,0);                  // et l'afficher. \r\n} \r\n```\r\n\r\n## 3) Pilotage d'un robot roulant :\r\nLa classe **lejos.robotics.navigation.DifferentialPilot** permet de piloter un robot roulant avec deux roues sur un même axe, contrôlées par deux moteurs séparés (châssis de type « chaise roulante ») et une roue libre dite « folle »: \r\nLes constructeurs permettent de déclarer la géométrie du châssis. Les paramètres de distance peuvent être dans une unité quelconque, pourvu que cette unité soit la même dans tout le programme.\r\n\r\nExemple pour un robot dont les roues gauche et droite sont sur les moteurs A et C : \r\n```java\r\nimport lejos.nxt.*; \r\nimport lejos.robotics.navigation.*; \r\n\r\nfinal double DIAM_ROUE = 2.1f;   // Diamètre des roues motrices en cm\r\nfinal double DIST_ROUE = 4.4f;   // Distance entre les roues motrices en cm\r\nDifferentialPilot pilot = new DifferentialPilot(DIAM_ROUE, DIST_ROUE, Motor.A, Motor.C); \r\npilot.setTravelSpeed(10);        // Vitesse du robot = 10 cm/s. \r\npilot.setRotateSpeed(45);        // Vitesse de pivotage = 45 degrés/s. \r\n```\r\n\r\nLes méthodes (bloquantes) **travel(...)**, **travelArc(...)** et **rotate(...)** permettent ensuite de faire se déplacer le robot en ligne droite, selon un arc de cercle ou de le faire pivoter sur lui même. \r\n\r\nExemple : \r\n```java\r\npilot.travel(12);                // Avancer de 12 cm.\r\npilot.rotate(-90);               // Pivoter de 90 degrés vers la gauche.\r\npilot.travel(-12);               // Reculer de 12 cm.\r\npilot.travelArc(10, 12);         // Faire un virage à gauche de 12 cm de long selon un rayon de 10 cm.\r\npilot.arc(-10, 90);              // Faire un virage à droite de 90 degrés selon un rayon de 10 cm.\r\n```\r\n\r\nLes méthodes (non-bloquantes) **forward()**, **backward()**, **arcForward()**, **arcBackward()** et **stop()** permettent de démarrer un moteur pour une durée indéterminée et de l'arrêter.\r\n\r\nExemple :\r\n```java\r\npilot.forward(); \t\t// Avancer en ligne droite indéfiniment. \r\nwhile(!Button.ENTER.isDown()) {\t// Tant que le bouton orange n'est pas pressé...\r\n       Thread.yield();           // Libérer le processeur. \r\n} \r\npilot.stop(); \t\t\t// Arrêter le robot. \r\n```\r\n\r\n## 4) Contrôle par tâches :\r\nUn programme qui a pour but de contrôler un robot doit être réactif : il doit pouvoir adapter son comportement en fonction de l'évolution du monde physique dans lequel il évolue (repères extérieurs, obstacles, vitesse des moteurs, etc.). Réaliser un tel programme sous forme d'une cascade de conditions et de boucles peut paraître simple et intuitif mais conduit rapidement à du « code spaghetti » : un enchevêtrement inextricable de cas particuliers, difficile à lire, à maintenir et à mettre au point. \r\n\r\nIl est possible d'utiliser un mécanisme de listeners, mais ceci conduit à des difficultés techniques et est découragé par les concepteurs de Lejos eux-mêmes. \r\n\r\nAu lieu de cela, le package lejos.robotics.subsumption fournit une architecture de contrôle par tâche qui permet de réaliser un programme réactif, de manière modulaire. Le principe est de décomposer le programme en plusieurs tâches qui sont exécutées au besoin (_programmation événementielle_), en respectant un ordre de priorité, plutôt que de manière prédéterminée par le programme (_programmation séquentielle_). Ceci permet de caractériser clairement chaque aspect du comportement, et d'ajouter facilement des tâches supplémentaires.\r\n\r\nPar exemple, un contrôleur de robot pourrait avoir les tâches suivantes : \r\n\r\n1. avancer en ligne droite \r\n\r\n2. si un obstacle est détecté, virer d'un quart de tour vers la gauche \r\n\r\n3. si un bouton est pressé, s'arrêter et mettre fin au programme. \r\n\r\n\r\nCes tâches sont en ordre croissant de priorité : la tâche 1 s'exécutant tant que les autres tâches (plus prioritaires) ne sont pas activées.\r\n\r\n### 4.1) Définir une tâche\r\nChaque tâche est définie par trois éléments, spécifiés par trois méthodes de l'interface Behavior : \r\n\r\n#### 4.1.1) La méthode **takeControl()**\r\nElle fournit la condition d'activation qui détermine quand cette tâche doit être initiée. On peut vouloir qu'une action soit activée si un obstacle se trouve à moins de 25cm (voir exemple ci-dessous), ou si le capteur tactile est pressé. On peut également vérifier des conditions multiples. Exemple : La tâche est activée si, à la fois le capteur photosensible détecte une ligne noire ET si la valeur booléenne d'une variable est à true. Pour que la tâche soit activée, il faut que la valeur retournée par la méthode **takecontrol()** soit **true**. \r\n\r\n#### 4.1.2) La méthode **action()**\r\nElle définit l'action que cette tâche doit accomplire (voir exemple ci-dessous). Cette méthode est appelée dès que la tâche devient active. \r\n\r\n#### 4.1.3) La méthode **suppress()** \r\nCette méthode permet la suppression (l'arrêt) de l'action en cours d'exécution. Elle permet aussi de mettre à jour des données avant la fin de la tâche. Elle est appelée par l'**Arbitrator** sur la tâche en cours si la méthode **takeControl()** d'une tâche plus prioritaire retourne **true**. Si cette tâche arrêtée est réactivée plus tard durant l'exéction du programme, la méthode **action()** sera à nouveau exécutée depuis le début et non depuis l'endroit où elle avait été arrêtée précédemment.  \r\n\r\nPour définir une tâche, il faut réaliser une implémentation de cette interface définissant ces trois méthodes. Il s'agit d'une forme de programmation événementielle : on fournit au système de contrôle du robot différentes tâches à exécuter lorsque différents événements surviennent. Par exemple, la tâche suivante effectue une manoeuvre lorsqu'un obstacle est détecté par le senseur à ultrasons (sonar) : \r\n\r\n```java\r\nimport lejos.robotics.navigation.DifferentialPilot; \r\nimport lejos.robotics.subsumption.Behavior; \r\nimport lejos.nxt.UltrasonicSensor; \r\n\r\npublic class EviterBehavior implements Behavior { \r\n\tprivate boolean suppressed = false; \r\n\tprivate DifferentialPilot pilote; \r\n\tprivate UltrasonicSensor sonar; \r\n\r\n\tpublic EviterBehavior(DifferentialPilot pilote, UltrasonicSensor sonar) { \r\n\t\tthis.pilote = pilote; \r\n\t\tthis.sonar = sonar; \r\n\t} \r\n\tpublic void action() { \r\n\t\tsuppressed = false;                     // Remise à zéro\t\r\n\t\tpilote.arc(20.0, -90.0, true);\t        // Entame un virage arrière sans attendre la fin. \r\n\t\twhile (!suppressed && pilote.isMoving()) {  // Tant que {suppress} n'a pas été  appelé et que le virage n'est pas terminé... \r\n\t\t\tThread.yield(); \t// libérer le processeur \r\n\t\t} \r\n\t\tpilote.stop(); \t  \t// Arrêter le robot \r\n\t} \r\n\tpublic void suppress() { \r\n\t\tsuppressed = true; \r\n\t} \r\n\tpublic boolean takeControl() { \t\r\n\t\t// Activer si un obstacle à moins de 25 cm \r\n\t\treturn sonar.getDistance() < 25; \r\n\t} \r\n} \r\n```\r\n\r\nAttention au mécanisme de suppression de tâche ! La méthode **suppress()** est exécutée alors que la méthode **action()** est elle-même toujours en cours d'exécution. Elle n'arrête pas simplement la tâche en cours; au lieu de cela, elle doit signaler à la méthode **action()** que celle-ci doit d'elle-même interrompre son activité. Pour assurer cette synchronisation, on utilise la variable d'instance **suppressed** comme suit : \r\n\r\n• La méthode **action()** met la variable **suppressed** à false initialement, \r\n\r\n• La méthode **suppress()**, lorsqu'elle est appelée, met la variable **suppressed** à true, \r\n\r\n• La méthode **action()** surveille continuellement la variable **suppressed** via la condition de boucle. \r\n\r\nSi la variable **suppressed** de la tâche en cours devient **true** (indiquant que la méthode suppress a été exécutée), le mouvement en cours est interrompu (pilote.stop()) et la méthode retourne immédiatement. La méthode doit donc utiliser des méthodes non-bloquantes sous peine d'ajouter un délai avant la prise en compte du passage de la variable à **true**. \r\n\r\nLa suppression (interruption) de la tâche n'est nécessaire que si action perdure dans le temps ; si elle se termine immédiatement il n'est pas nécessaire de mettre en place un mécanisme pour la supprimer. Par exemple, l'action de la tâche suivante quittant immédiatement le programme il est inutile de prévoir sa suppression. \r\n\r\n```java\r\npublic class StopBehavior implements Behavior { \r\n\tprivate DifferentialPilot pilote; \r\n\r\n\tpublic StopBehavior(DifferentialPilot pilote) { \r\n\t\tthis.pilote = pilote; \r\n\t} \r\n\r\n\tpublic void action() { \r\n\t\tpilote.stop(); \t\t// Arrêter le robot.\r\n\t\tSystem.exit(0); \t\t// Quitter le programme. \r\n\t} \r\n\r\n\tpublic void suppress() { \t// Rien à supprimer.\r\n\t} \r\n\r\n\tpublic boolean takeControl() { \t\r\n\t\t// Activer si le bouton ESCAPE est pressé. \r\n\t\treturn Button.ESCAPE.isDown(); \r\n\t} \r\n} \r\n```\r\n\r\n### 4.2) Créer un contrôleur\r\nLa classe **Arbitrator** permet de construire et d'activer un contrôleur par tâche. Son constructeur prend en paramètre un tableau contenant les tâches que le robot sera succeptible d'effectuer et que l'**Arbitrator** devra gérer. Les tâches doivent être ordonnées par _ordre croissant de priorité_. La méthode **start()** permet d'activer l'**Arbitrator**. \r\n\r\nExemple : \r\n```java\r\nDifferentialPilot pilote = new DifferentialPilot(DIAM_ROUE, DIST_ROUE, Motor.A, Motor.C); \r\nUltrasonicSensor sonar = new UltrasonicSensor(SensorPort.S1);\r\n\r\nBehavior avancer = new AvancerBehavior(pilote); \t    // Tâche avancer (tout droit indéfiniment).\r\nBehavior eviter = new EviterBehavior(pilote, sonar); // Tâche eviter (manoeuvre arrière en cas d'obstacle).\r\nBehavior stop = new StopBehavior(pilote);            // Tâche stop (arrêter tout si un bouton est appuyé). \r\nBehavior[] taches = { avancer, eviter, stop };       // Tableau de tâches dans l'ordre croissant de priorité.\r\nArbitrator arbitre = new Arbitrator(taches); \r\narbitre.start(); \r\n```\r\n\r\nUne tâche ne sera activée que si elle est plus prioritaire que la tâche en cours, et pourra être interrompue par une tâche plus prioritaire qu'elle. L'activation et l'interruption d'une tâche ne peut avoir lieu qu'au moment où la tâche en cours exécute une méthode non bloquante. Simultanément, le contrôleur évalue en permanence les méthodes **takeControl()** de la liste des tâches et initie la tâche la plus prioritaire pour laquelle la méthode **takeControl()** retourne **true**, en appelant au besoin **suppress()** pour supprimer la tâche en cours (moins prioritaire). \r\nAttention : le bon fonctionnement de ce mécanisme dépend du fait que la méthode action() de chaque tâche se termine rapidement lorsque la méthode **suppress()** est appelée. \r\n\r\nA tout moment, une seule tâche est activée ; une nouvelle tâche ne peut s'enclencher que lorsque la tâche en cours s'interrompt. Pour ce faire, le contrôleur appelle uniquement **suppress()** de la tâche en cours (moins prioritaire), puis appelle **action()** de la tâche à activer. Il ne peut pas forcer l'arrêt de l'exécution de action. Il est donc important de bien appliquer le mécanisme de suppression des tâches décrit précédemment. \r\n\r\n# 5) Remarques et conseils:\r\nUn exemple complet nommé **SimpleController**, dont sont tirés les extraits présentés ici, est disponible sur [GitHub](https://github.com/NDetienne/ProjetP1). Utilisez-le comme point de départ. \r\n\r\nRespectez bien les recommandations suivantes concernant la synchronisation afin d'éviter des problèmes de blocages et de conflits difficiles à diagnostiquer : \r\n\r\n• Soyez attentifs à la différence entre méthodes bloquantes et non-bloquantes. \r\n\r\n• Utilisez yield et/ou sleep à bon escient pour ne pas accaparer le processeur. \r\n\r\n• Utilisez correctement la variable **suppressed** pour la suppression des tâches ainsi que les tests de valeurs de cette variable.\r\n\r\n• Assurez-vous que vos tâches s'interrompent bien lorsque demandé. \r\n\r\nIl est prudent d'avoir comme tâche de plus haute priorité une tâche d'arrêt d'urgence conditionnée sur un bouton du robot (par exemple la tâche StopBehavior de l'exemple fourni). \r\n\r\nLes senseurs, moteurs et pièces mécaniques appartiennent au domaine de la physique : leur précision peut donc varier, une étape de calibrage peut être nécessaire... \r\n\r\n# 6) Documentation :\r\n\r\n1. [Manuel de l’utilisateur NXT](http://isn.codelab.info/site/assets/files/1637/guide_nxt.pdf)\r\n\r\n2. [The leJOS NXJ Tutorial.](http://www.lejos.org/rcx/tutorial/index.html) \r\n\r\n3. [The leJOS NXJ API.](http://lejos.sourceforge.net/nxt/nxj/api/index.html) \r\n\r\n4. Pour un exemple complet, voir le programme SimpleController sur [GitHub](https://github.com/NDetienne/ProjetP1)",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}